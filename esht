#!/bin/sh
# esht - Embeddable SHell Tags parser thingie
# Licensed under the The Unlicense.
# For more information, please refer to <https://unlicense.org>

# This script should not be sourced, make sure to change the string 'esht'
#   to match this file's name
[ 'esht' = "$( basename ${0} )" ] || return 1

SCRIPT=$( basename "$0" )
VMAJOR=1
VMINOR=2
VPATCH=0
HOMEPAGE="https://gitlab.com/4bcx/esht"
SCRIPT_URL="https://gitlab.com/4bcx/esht/-/raw/dev/esht"
VERSION_URL="https://gitlab.com/4bcx/esht/-/raw/dev/VERSION"
UPDATE_LOCK="/tmp/esht.lock"

if [ -f ${UPDATE_LOCK} ] &&
	[ $( grep -c 'done' ${UPDATE_LOCK} ) -gt 0 ]; then
		printf '%s updated successfully\n' "${0}"
		rm ${UPDATE_LOCK}
		exit 0
fi

print_help () {
	cat << END_OF_HELP_TEXT
${SCRIPT} v${VMAJOR}.${VMINOR}.${VPATCH}
Embeddable SHell Tags parser thingie

Usage: ${SCRIPT} SOURCE [OUTPUT]
       ${SCRIPT} -x SOURCE
       ${SCRIPT} -h | -v | -u
Compile SOURCE into shell script OUTPUT or standard output.

Options:
  -h, --help                    display this help text and exit
  -v, --version                 print version and exit
  -x, --execute                 execute the output script instead of writing
                                it to a file
  -u, --update                  update ${SCRIPT}

Project homepage: <"${HOMEPAGE}">
END_OF_HELP_TEXT
}

print_version () {
	VERSION="${VMAJOR}.${VMINOR}.${VPATCH}"
	printf '%s Version %s\n' "${SCRIPT}" "${VERSION}"
}

print_error () {
	ERROR_MSG=${1:-Unknown error}
	printf '%s: %s\n' "${SCRIPT}" "${ERROR_MSG}" >&2
}

write_to_file () {
	printf "$@" >> "${OUTPUT_FILE}"
}

write_to_stdout () {
	printf "$@" >&1
}

script_update () {
	if [ -f ${UPDATE_LOCK} ] &&
		[ $( grep -c 'updating' ${UPDATE_LOCK} ) -gt 0 ]; then
			print_error 'Another update process is running'
			exit 1
	fi

	UVERSION_FILE=$( mktemp )
	wget -q -O ${UVERSION_FILE} ${VERSION_URL} 2> /dev/null
	UMAJOR=$( cut -d . -f 1 ${UVERSION_FILE} )
	UMINOR=$( cut -d . -f 2 ${UVERSION_FILE} )
	UPATCH=$( cut -d . -f 3 ${UVERSION_FILE} )
	rm ${UVERSION_FILE}

	if ( [ ${UMAJOR} -gt ${VMAJOR} ] ) || ( [ ${UMAJOR} -eq ${VMAJOR} ] &&
		[ ${UMINOR} -gt ${VMINOR} ] ) || ( [ ${UMAJOR} -eq ${VMAJOR} ] &&
		[ ${UMINOR} -eq ${VMINOR} ] && [ ${UPATCH} -gt ${VPATCH} ] ); then

		printf 'updating\n' > ${UPDATE_LOCK}
		NEW_SCRIPT_FILE=$( mktemp )
		UPDATER_SCRIPT=$( mktemp )
		wget -q -O ${NEW_SCRIPT_FILE} ${SCRIPT_URL} 2> /dev/null

		cat << END_OF_UPDATER_SCRIPT > ${UPDATER_SCRIPT}
cp ${NEW_SCRIPT_FILE} ${0}
rm -f ${NEW_SCRIPT_FILE}
printf 'done\n' > ${UPDATE_LOCK}
exec ${0}
END_OF_UPDATER_SCRIPT

		chmod +x ${NEW_SCRIPT_FILE}
		chmod +x ${UPDATER_SCRIPT}

		exec ${UPDATER_SCRIPT}
	else
		printf 'No newer version found\n'
	fi
}

script_main () {
	BLOCK=''
	PCHAR=''
	STACK=0
	TRAIL=0
	ISIZE=$( wc -c "${INPUT_FILE}" | cut -f 1 -d ' ' )

	od -v -c -w1 -Ad "${INPUT_FILE}" | while read -r INDEX ICHAR; do
		if [ "${BLOCK}" = 'shell' ]; then
			if [ "${ICHAR}" = '[' ]; then
				STACK=$(( STACK + 1 ))
			elif [ "${ICHAR}" = ']' ] && [ ${STACK} -eq 0 ]; then
				${write_output} '\n'
				TRAIL=0
				BLOCK=''
				continue
			elif [ "${ICHAR}" = ']' ] && [ ${STACK} -gt 0 ]; then
				STACK=$(( STACK - 1 ))
			elif [ "${PCHAR}${ICHAR}" = '$[' ] && [ ${STACK} -eq 0 ]; then
				PCHAR='$['
				continue
			elif [ -z "${ICHAR}" ]; then
				TRAIL=$(( TRAIL + 1 ))
				continue
			elif [ -n "${ICHAR}" ] && [ ${TRAIL} -gt 0 ]; then
				${write_output} "%${TRAIL}s"
				TRAIL=0
			fi

			${write_output} "${ICHAR}"

		elif [ "${BLOCK}" = 'print' ]; then
			if [ "${ICHAR}" = '\' ]; then
				PCHAR='\'
				continue
			elif [ "${PCHAR}${ICHAR}" = '\$' ]; then
				PCHAR='\$'
				continue
			elif [ "${PCHAR}${ICHAR}" = '\$[' ]; then
				PCHAR='\'
				ICHAR='$['
			elif [ "${ICHAR}" = '$' ]; then
				PCHAR='$'
				continue
			elif [ "${PCHAR}${ICHAR}" = '$[' ]; then
				PCHAR='$['
				${write_output} "'\n"
				BLOCK='shell'
				continue
			fi

			if [ ${INDEX} -eq ${ISIZE} ]; then
				${write_output} "'\n"
			else
				${write_output} '%s' "${ICHAR:= }"
			fi

		else
			if [ "${ICHAR}" = '$' ]; then
				PCHAR='$'
				continue
			elif [ "${PCHAR}${ICHAR}" = '$[' ]; then
				PCHAR='$['
				BLOCK='shell'
				continue
			else
				BLOCK='print'
				${write_output} "printf '"
				if [ "${PCHAR}" = '$' ]; then
					${write_output} '$'
				fi
			fi
			${write_output} '%s' "${ICHAR:= }"
		fi
		
		PCHAR="${ICHAR}"
	done
}

INPUT_FILE=''

if [ $# -eq 0 ]; then
	print_error "Missing source filename"
	print_help >&2
	exit 5
elif [ $# -gt 2 ]; then
	print_error "${3}: Cannot use more than two arguments"
	print_help >&2
	exit 22
else
	case "${1}" in
		-h|--help)
			print_help
			exit 0
			;;
		-v|--version)
			print_version
			exit 0
			;;
		-x|--execute)
			INPUT_FILE="${2}"
			OUTPUT_FILE=$( mktemp )
			SHEXE='true'
			;;
		-u|--update)
			script_update
			exit 0
			;;
		*)
			INPUT_FILE="${1}"
			if [ -n "${2}" ] && [ -f "${2}" ]; then
				print_error "${2}: File exists and will be overwritten"
				OUTPUT_FILE="${2}"
			fi
			if [ -f "${1}" ]; then
				INPUT_FILE="${1}"
			else
				print_error "${1}: File cannot be opened or does not exist"
				exit 2
			fi
	esac

	if [ ! -f "${INPUT_FILE}" ]; then
		print_error "${INPUT_FILE}: File cannot be opened or does not exist"
		exit 2
	fi
	if [ -n "${OUTPUT_FILE}" ]; then
		: > "${OUTPUT_FILE}"
		write_output='write_to_file'
	else
		write_output='write_to_stdout'
	fi
fi

trap "print_error 'Interrupt signal detected, output may be incomplete'" INT

script_main

if [ "${SHEXE}" = 'true' ]; then
	chmod +x ${OUTPUT_FILE}
	${OUTPUT_FILE}
	rm ${OUTPUT_FILE}
fi
